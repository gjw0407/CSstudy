# 트랜잭션

> 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들
> 

## 트랜잭션의 특징

1. 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위이다. 
2. 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업단위이다.
3. 하나의 트랜잭션은 commit되거나 rollback된다.

## 트랜잭션의 성질(ACID)

### Atomicity(원자성)

1. 트랜잭션의 연산은 데이터베이스에 모두 반영되든지 아니면 전혀 반영되지 않아야 한다.
2. 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

### Consistency(일관성)

1. 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.
2. 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 한다. 

### Isolation(독립성, 격리성)

1. 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다.
2. 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다. 

### Durability(영속성, 지속성)

1. 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.

## 트랜잭션 연산 및 상태

### Commit 연산

> 한 개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
> 

### Rollback 연산

> Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨트렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소하는 연산
> 

Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기한다.

# 트랜잭션 격리 수준(Transaction Isolation Level)

> 동시에 여러 트랜잭션이 처리될 때, **트랜잭션끼리 얼마나 서로 고립되어 있는지**를 나타내는 것이다.
즉, 특정 트랜잭션이 다른 트랜잭션이 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정한다.
> 

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 된다. 하지만, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생할 수 있다.

따라서 최대한 효율적인 Locking 방법이 필요하다.

- 공유(shared) lock : 데이터를 읽을 때 사용되는 lock
    - 공유 락은 공유 락끼리 동시에 접근 가능하다.
    - 하지만 공유 락이 설정된 데이터에 배타 락을 사용할 수는 없다.
- 배타(Exclusive) lock : 데이터를 변경하고자 할 때 사용되며, 트랜잭션이 완료될 때까지 유지된다.
    - 락이 해제될 때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근할 수 없다.
    - 해당 락은 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 락을 설정할 수 없다.

## Isolation level 종류

1. **Read Uncommitted** (레벨 0)
    - SELECT 문장이 수행되는 동안 **해당 데이터에 Shared Lock이 걸리지 않는 계층**
    - 트랜잭션에 처리 중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함.
    - 데이터베이스의 **일관성을 유지하는 것이 불가능**함.
    - **Dirty Read 발생**
        - A 트랜잭션에서 10번 사원의 나이를 27에서 28로 바꿈. 아직 커밋하지 않음
        - B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 28 → Dirty Read
            - 이 이후, A 트랜잭션에서 문제가 발생해 Rollback함
            - B 트랜잭션은 10번 사원이 여전히 28살이라 생각하고 로직을 수행함
            - 이런 식으로 데이터 정합성에 문제가 많아짐
2. **Read Committed** (레벨 1)
    - SELECT 문장이 수행되는  동안 **해당 데이터에 Shared Lock이 걸리는 계층**
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
    - **Commit이 이루어진 트랜잭션만 조회 가능**
    - Oracle DB, SQL Server에서 기본으로 사용하는 Isolation level임
    - **Non-Repeatable Read 발생**
        - B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 27
        - A 트랜잭션에서 10번 사원의 나이를 27에서 28로 바꾸고 커밋
        - B 트랜잭션에서 10번 사원의 나이를 조회 : 결과 28
3. **Repeatable Read** (레벨 2)
    - 트랜잭션이 완료될 때까지 **SELECT 문장이 사용되는 모든 데이터에 Shared Lock이 걸리는 계층**
    - 트랜잭션이 범위 내에서 **조회한 데이터 내용이 항상 동일함을 보장**함
    - 다른 사용자는 **트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능**
    - Mysql DBMS에서 기본으로 사용함.
    - Non-Repeatable Read 부정합이 발생하지 않음
        - 10번 트랜잭션이 500번 사원을 조회
        - 12번 트랜잭션이 500번 사원의 이름을 변경하고 커밋
        - 10번 트랜잭션이 500번 사원을 다시 조회 : undo 영역에 백업된 데이터 반환
    - 즉, 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(커밋된) 것만 보게 된다.
        - 모든 InnoDB의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션 번호를 갖고 있으며,
        - undo 영역에 백업된 모든 레코드는 변경을 발생시킨 트랜잭션의 번호를 포함하고 있다.
        - Phantom Read 발생
4. **Serializable** (레벨 3)
    - 트랜잭션이 완료될 때까지 **SELECT 문장이 사용되는 모든 데이터에 Exclusive Lock이 걸리는 계층**
    - 가장 엄격한 격리 수준으로 **완벽한 읽기 일관성 모드를 제공**함
    - 다른 사용자는 **트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능**

레벨이 높아질수록 트랜잭션 간 고립 정도가 높아지며, 성능이 떨어지는 것이 일반적이며, 일반적인 온라인 서비스에서는 READ COMMITTED나 REPEATABLE READ 중 하나를 사용한다.

Isolation level에 대한 조정은 동시성과 데이터 무결성에 연관되어 있다.

```
동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 된다.
```