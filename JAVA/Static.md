# Static

# 개념

- 정적 변수와 정적 메소드 생성
    - 프로그램이 종료되기 전까지 사용 가능
    - GC에 의해 수집 되지 않음 (정적 객체는 GC에 의해 수집 가능)
- 동적 : 객체를 런타임 도중에 힙 영역에 할당
- 정적 : 프로그램이 시작되는 시점에 클래스 로더가 클래스를 해석해 메소드 영역 혹은 힙 영역에 클래스 메타 데이터 및 정적 변수를 적재

# 저장 공간

## Permanent vs Metaspace

Permanent

- Java 8 이전에 존재
- 클래스 내부의 메타 데이터를 저장
- 힙 영역 안에 존재
    - 클래스, 메소드 메타 데이터, 정적 객체, 정적 변수, 상수 풀 등 관리

Metaspace

- Java 8 부터 존재
- 네이티브 메모리 영역으로서 JVM이 아닌 OS에서 관리
    - 네이티브 메모리 : OS가 할당한 메모리이며 C언어 코드로 실행되는 Java 프로세스를 담는다
- 메소드 영역이 네이티브 메모리 영역에 포함

## Java 8 이후

![Untitled](https://user-images.githubusercontent.com/61227459/181016900-3f986223-3195-417c-bb37-fc8a02858a98.png)

- Permanent 영역이 사라짐 → 힙 외부에서 Metaspace라고 하는 네이티브 메모리에서 Permanent가 저장하던 정보를 저장
- static을 힙 영역에서 관리

## Permanent 사라진 이유

<aside>
💡 클래스 메타 데이터를 힙 영역에서 관리 → 힙 영역에 들어간 데이터의 사이즈를 계산하기 어려워 OOM(Out of Memory 오류)가 자주 발생

</aside>

# Static로 인해 발생하는 문제

1. 메모리 문제
    1. 프로그램 실행 시점에 메모리 할당 → 프로그램 종료 시점까지 메모리에서 해제되지 X
2. 동시성 이슈 문제
    1. 전역에서 접근이 가능 → 동기화 전략을 수립해야 함
3. 런타임 다형성 불가
    1. static으로 이뤄진 메소드를 사용할 경우 → 객체.메소드로 바로 접근하여 호출
4. 객체의 상태를 이용 X
    1. 정적 메소드를 사용하기 위해서는 필요로 하는 인자를 모두 외부에서 주입해야 함
    2. 정적 메소드 안에는 클래스의 인스턴스 필드를 사용 불가
    3. 일반 메소드라면 객체 내의 있는 상태를 통해 해당 메소드를 구현 가능 → 변화하는 상태에 따라 다채로운 기능 구현이 가능
    4. 객체 내의 정적 메소드가 많다 = 외부 값에 의존하는 수동적인 객체
5. 테스트가 어려움
    1. 프로그램 전체에서 필드에 접근하고 수정 가능 → 필드를 추론하는데 어려워 테스트가 까다로움

# Static을 사용하는 때

1. 상수 정의

```java
private static final String NAME = "이름";
```

1. 유틸리티 클래스 정의
    1. 객체의 상태를 이용할 생각이 X, 여러 객체들의 필요에 의해 데이터를 처리하는 **공통 로직**이 필요할 때 (ex. Math 클래스)

# 출처

[https://medium.com/swlh/native-memory-the-silent-jvm-killer-595913cba8e7](https://medium.com/swlh/native-memory-the-silent-jvm-killer-595913cba8e7)